{"ast":null,"code":"/**\n * An object representing a \"promise\" for a future value\n *\n * @param {?function(T, ?)=} onSuccess a function to handle successful\n *     resolution of this promise\n * @param {?function(!Error, ?)=} onFail a function to handle failed\n *     resolution of this promise\n * @constructor\n * @template T\n */\nfunction Promise(onSuccess, onFail) {\n  this.promise = this;\n  this._isPromise = true;\n  this._successFn = onSuccess;\n  this._failFn = onFail;\n  this._scope = this;\n  this._boundArgs = null;\n  this._hasContext = false;\n  this._nextContext = undefined;\n  this._currentContext = undefined;\n}\n\n/**\n * Specify that the current promise should have a specified context\n * @param  {*} context context\n * @private\n */\nPromise.prototype._useContext = function (context) {\n  this._nextContext = this._currentContext = context;\n  this._hasContext = true;\n  return this;\n};\nPromise.prototype.clearContext = function () {\n  this._hasContext = false;\n  this._nextContext = undefined;\n  return this;\n};\n\n/**\n * Set the context for all promise handlers to follow\n *\n * NOTE(dpup): This should be considered deprecated.  It does not do what most\n * people would expect.  The context will be passed as a second argument to all\n * subsequent callbacks.\n *\n * @param {*} context An arbitrary context\n */\nPromise.prototype.setContext = function (context) {\n  this._nextContext = context;\n  this._hasContext = true;\n  return this;\n};\n\n/**\n * Get the context for a promise\n * @return {*} the context set by setContext\n */\nPromise.prototype.getContext = function () {\n  return this._nextContext;\n};\n\n/**\n * Resolve this promise with a specified value\n *\n * @param {*=} data\n */\nPromise.prototype.resolve = function (data) {\n  if (this._error || this._hasData) throw new Error(\"Unable to resolve or reject the same promise twice\");\n  var i;\n  if (data && isPromise(data)) {\n    this._child = data;\n    if (this._promises) {\n      for (i = 0; i < this._promises.length; i += 1) {\n        data._chainPromise(this._promises[i]);\n      }\n      delete this._promises;\n    }\n    if (this._onComplete) {\n      for (i = 0; i < this._onComplete.length; i += 1) {\n        data.fin(this._onComplete[i]);\n      }\n      delete this._onComplete;\n    }\n  } else if (data && isPromiseLike(data)) {\n    data.then(function (data) {\n      this.resolve(data);\n    }.bind(this), function (err) {\n      this.reject(err);\n    }.bind(this));\n  } else {\n    this._hasData = true;\n    this._data = data;\n    if (this._onComplete) {\n      for (i = 0; i < this._onComplete.length; i++) {\n        this._onComplete[i]();\n      }\n    }\n    if (this._promises) {\n      for (i = 0; i < this._promises.length; i += 1) {\n        this._promises[i]._withInput(data);\n      }\n      delete this._promises;\n    }\n  }\n};\n\n/**\n * Reject this promise with an error\n *\n * @param {!Error} e\n */\nPromise.prototype.reject = function (e) {\n  if (this._error || this._hasData) throw new Error(\"Unable to resolve or reject the same promise twice\");\n  var i;\n  this._error = e;\n  if (this._ended) {\n    process.nextTick(function onPromiseThrow() {\n      throw e;\n    });\n  }\n  if (this._onComplete) {\n    for (i = 0; i < this._onComplete.length; i++) {\n      this._onComplete[i]();\n    }\n  }\n  if (this._promises) {\n    for (i = 0; i < this._promises.length; i += 1) {\n      this._promises[i]._withError(e);\n    }\n    delete this._promises;\n  }\n};\n\n/**\n * Provide a callback to be called whenever this promise successfully\n * resolves. Allows for an optional second callback to handle the failure\n * case.\n *\n * @param {?function(this:void, T, ?): RESULT|undefined} onSuccess\n * @param {?function(this:void, !Error, ?): RESULT=} onFail\n * @return {!Promise.<RESULT>} returns a new promise with the output of the onSuccess or\n *     onFail handler\n * @template RESULT\n */\nPromise.prototype.then = function (onSuccess, onFail) {\n  var promise = new Promise(onSuccess, onFail);\n  if (this._nextContext) promise._useContext(this._nextContext);\n  if (this._child) this._child._chainPromise(promise);else this._chainPromise(promise);\n  return promise;\n};\n\n/**\n * Provide a callback to be called whenever this promise successfully\n * resolves. The callback will be executed in the context of the provided scope.\n *\n * @param {function(this:SCOPE, T, ?): RESULT} onSuccess\n * @param {SCOPE} scope Object whose context callback will be executed in.\n * @param {...*} var_args Additional arguments to be passed to the promise callback.\n * @return {!Promise.<RESULT>} returns a new promise with the output of the onSuccess\n * @template SCOPE, RESULT\n */\nPromise.prototype.thenBound = function (onSuccess, scope, var_args) {\n  var promise = new Promise(onSuccess);\n  if (this._nextContext) promise._useContext(this._nextContext);\n  promise._scope = scope;\n  if (arguments.length > 2) {\n    promise._boundArgs = Array.prototype.slice.call(arguments, 2);\n  }\n\n  // Chaining must happen after setting args and scope since it may fire callback.\n  if (this._child) this._child._chainPromise(promise);else this._chainPromise(promise);\n  return promise;\n};\n\n/**\n * Provide a callback to be called whenever this promise is rejected\n *\n * @param {function(this:void, !Error, ?)} onFail\n * @return {!Promise.<T>} returns a new promise with the output of the onFail handler\n */\nPromise.prototype.fail = function (onFail) {\n  return this.then(null, onFail);\n};\n\n/**\n * Provide a callback to be called whenever this promise is rejected.\n * The callback will be executed in the context of the provided scope.\n *\n * @param {function(this:SCOPE, Error, ?)} onFail\n * @param {SCOPE} scope Object whose context callback will be executed in.\n * @param {...?} var_args\n * @return {!Promise.<T>} returns a new promise with the output of the onSuccess\n * @template SCOPE\n */\nPromise.prototype.failBound = function (onFail, scope, var_args) {\n  var promise = new Promise(null, onFail);\n  if (this._nextContext) promise._useContext(this._nextContext);\n  promise._scope = scope;\n  if (arguments.length > 2) {\n    promise._boundArgs = Array.prototype.slice.call(arguments, 2);\n  }\n\n  // Chaining must happen after setting args and scope since it may fire callback.\n  if (this._child) this._child._chainPromise(promise);else this._chainPromise(promise);\n  return promise;\n};\n\n/**\n * Provide a callback to be called whenever this promise is either resolved\n * or rejected.\n *\n * @param {function()} onComplete\n * @return {!Promise.<T>} returns the current promise\n */\nPromise.prototype.fin = function (onComplete) {\n  if (this._hasData || this._error) {\n    onComplete();\n    return this;\n  }\n  if (this._child) {\n    this._child.fin(onComplete);\n  } else {\n    if (!this._onComplete) this._onComplete = [onComplete];else this._onComplete.push(onComplete);\n  }\n  return this;\n};\n\n/**\n * Mark this promise as \"ended\". If the promise is rejected, this will throw an\n * error in whatever scope it happens to be in\n *\n * @return {!Promise.<T>} returns the current promise\n * @deprecated Prefer done(), because it's consistent with Q.\n */\nPromise.prototype.end = function () {\n  this._end();\n  return this;\n};\n\n/**\n * Mark this promise as \"ended\".\n * @private\n */\nPromise.prototype._end = function () {\n  if (this._error) {\n    throw this._error;\n  }\n  this._ended = true;\n  return this;\n};\n\n/**\n * Close the promise. Any errors after this completes will be thrown to the global handler.\n *\n * @param {?function(this:void, T, ?)=} onSuccess a function to handle successful\n *     resolution of this promise\n * @param {?function(this:void, !Error, ?)=} onFailure a function to handle failed\n *     resolution of this promise\n * @return {void}\n */\nPromise.prototype.done = function (onSuccess, onFailure) {\n  var self = this;\n  if (onSuccess || onFailure) {\n    self = self.then(onSuccess, onFailure);\n  }\n  self._end();\n};\n\n/**\n * Return a new promise that behaves the same as the current promise except\n * that it will be rejected if the current promise does not get fulfilled\n * after a certain amount of time.\n *\n * @param {number} timeoutMs The timeout threshold in msec\n * @param {string=} timeoutMsg error message\n * @return {!Promise.<T>} a new promise with timeout\n */\nPromise.prototype.timeout = function (timeoutMs, timeoutMsg) {\n  var deferred = new Promise();\n  var isTimeout = false;\n  var timeout = setTimeout(function () {\n    deferred.reject(new Error(timeoutMsg || 'Promise timeout after ' + timeoutMs + ' ms.'));\n    isTimeout = true;\n  }, timeoutMs);\n  this.then(function (data) {\n    if (!isTimeout) {\n      clearTimeout(timeout);\n      deferred.resolve(data);\n    }\n  }, function (err) {\n    if (!isTimeout) {\n      clearTimeout(timeout);\n      deferred.reject(err);\n    }\n  });\n  return deferred.promise;\n};\n\n/**\n * Attempt to resolve this promise with the specified input\n *\n * @param {*} data the input\n */\nPromise.prototype._withInput = function (data) {\n  if (this._successFn) {\n    try {\n      this.resolve(this._call(this._successFn, [data, this._currentContext]));\n    } catch (e) {\n      this.reject(e);\n    }\n  } else this.resolve(data);\n\n  // context is no longer needed\n  delete this._currentContext;\n};\n\n/**\n * Attempt to reject this promise with the specified error\n *\n * @param {!Error} e\n * @private\n */\nPromise.prototype._withError = function (e) {\n  if (this._failFn) {\n    try {\n      this.resolve(this._call(this._failFn, [e, this._currentContext]));\n    } catch (thrown) {\n      this.reject(thrown);\n    }\n  } else this.reject(e);\n\n  // context is no longer needed\n  delete this._currentContext;\n};\n\n/**\n * Calls a function in the correct scope, and includes bound arguments.\n * @param {Function} fn\n * @param {Array} args\n * @return {*}\n * @private\n */\nPromise.prototype._call = function (fn, args) {\n  if (this._boundArgs) {\n    args = this._boundArgs.concat(args);\n  }\n  return fn.apply(this._scope, args);\n};\n\n/**\n * Chain a promise to the current promise\n *\n * @param {!Promise} promise the promise to chain\n * @private\n */\nPromise.prototype._chainPromise = function (promise) {\n  var i;\n  if (this._hasContext) promise._useContext(this._nextContext);\n  if (this._child) {\n    this._child._chainPromise(promise);\n  } else if (this._hasData) {\n    promise._withInput(this._data);\n  } else if (this._error) {\n    promise._withError(this._error);\n  } else if (!this._promises) {\n    this._promises = [promise];\n  } else {\n    this._promises.push(promise);\n  }\n};\n\n/**\n * Utility function used for creating a node-style resolver\n * for deferreds\n *\n * @param {!Promise} deferred a promise that looks like a deferred\n * @param {Error=} err an optional error\n * @param {*=} data optional data\n */\nfunction resolver(deferred, err, data) {\n  if (err) deferred.reject(err);else deferred.resolve(data);\n}\n\n/**\n * Creates a node-style resolver for a deferred by wrapping\n * resolver()\n *\n * @return {function(?Error, *)} node-style callback\n */\nPromise.prototype.makeNodeResolver = function () {\n  return resolver.bind(null, this);\n};\n\n/**\n * Return true iff the given object is a promise of this library.\n *\n * Because kew's API is slightly different than other promise libraries,\n * it's important that we have a test for its promise type. If you want\n * to test for a more general A+ promise, you should do a cap test for\n * the features you want.\n *\n * @param {*} obj The object to test\n * @return {boolean} Whether the object is a promise\n */\nfunction isPromise(obj) {\n  return !!obj._isPromise;\n}\n\n/**\n * Return true iff the given object is a promise-like object, e.g. appears to\n * implement Promises/A+ specification\n *\n * @param {*} obj The object to test\n * @return {boolean} Whether the object is a promise-like object\n */\nfunction isPromiseLike(obj) {\n  return typeof obj === 'object' && typeof obj.then === 'function';\n}\n\n/**\n * Static function which creates and resolves a promise immediately\n *\n * @param {T} data data to resolve the promise with\n * @return {!Promise.<T>}\n * @template T\n */\nfunction resolve(data) {\n  var promise = new Promise();\n  promise.resolve(data);\n  return promise;\n}\n\n/**\n * Static function which creates and rejects a promise immediately\n *\n * @param {!Error} e error to reject the promise with\n * @return {!Promise}\n */\nfunction reject(e) {\n  var promise = new Promise();\n  promise.reject(e);\n  return promise;\n}\n\n/**\n * Replace an element in an array with a new value. Used by .all() to\n * call from .then()\n *\n * @param {!Array} arr\n * @param {number} idx\n * @param {*} val\n * @return {*} the val that's being injected into the array\n */\nfunction replaceEl(arr, idx, val) {\n  arr[idx] = val;\n  return val;\n}\n\n/**\n * Replace an element in an array as it is resolved with its value.\n * Used by .allSettled().\n *\n * @param {!Array} arr\n * @param {number} idx\n * @param {*} value The value from a resolved promise.\n * @return {*} the data that's being passed in\n */\nfunction replaceElFulfilled(arr, idx, value) {\n  arr[idx] = {\n    state: 'fulfilled',\n    value: value\n  };\n  return value;\n}\n\n/**\n * Replace an element in an array as it is rejected with the reason.\n * Used by .allSettled().\n *\n * @param {!Array} arr\n * @param {number} idx\n * @param {*} reason The reason why the original promise is rejected\n * @return {*} the data that's being passed in\n */\nfunction replaceElRejected(arr, idx, reason) {\n  arr[idx] = {\n    state: 'rejected',\n    reason: reason\n  };\n  return reason;\n}\n\n/**\n * Takes in an array of promises or literals and returns a promise which returns\n * an array of values when all have resolved. If any fail, the promise fails.\n *\n * @param {!Array.<!Promise>} promises\n * @return {!Promise.<!Array>}\n */\nfunction all(promises) {\n  if (arguments.length != 1 || !Array.isArray(promises)) {\n    promises = Array.prototype.slice.call(arguments, 0);\n  }\n  if (!promises.length) return resolve([]);\n  var outputs = [];\n  var finished = false;\n  var promise = new Promise();\n  var counter = promises.length;\n  for (var i = 0; i < promises.length; i += 1) {\n    if (!promises[i] || !isPromiseLike(promises[i])) {\n      outputs[i] = promises[i];\n      counter -= 1;\n    } else {\n      promises[i].then(replaceEl.bind(null, outputs, i)).then(function decrementAllCounter() {\n        counter--;\n        if (!finished && counter === 0) {\n          finished = true;\n          promise.resolve(outputs);\n        }\n      }, function onAllError(e) {\n        if (!finished) {\n          finished = true;\n          promise.reject(e);\n        }\n      });\n    }\n  }\n  if (counter === 0 && !finished) {\n    finished = true;\n    promise.resolve(outputs);\n  }\n  return promise;\n}\n\n/**\n * Takes in an array of promises or values and returns a promise that is\n * fulfilled with an array of state objects when all have resolved or\n * rejected. If a promise is resolved, its corresponding state object is\n * {state: 'fulfilled', value: Object}; whereas if a promise is rejected, its\n * corresponding state object is {state: 'rejected', reason: Object}.\n *\n * @param {!Array} promises or values\n * @return {!Promise.<!Array>} Promise fulfilled with state objects for each input\n */\nfunction allSettled(promises) {\n  if (!Array.isArray(promises)) {\n    throw Error('The input to \"allSettled()\" should be an array of Promise or values');\n  }\n  if (!promises.length) return resolve([]);\n  var outputs = [];\n  var promise = new Promise();\n  var counter = promises.length;\n  for (var i = 0; i < promises.length; i += 1) {\n    if (!promises[i] || !isPromiseLike(promises[i])) {\n      replaceElFulfilled(outputs, i, promises[i]);\n      if (--counter === 0) promise.resolve(outputs);\n    } else {\n      promises[i].then(replaceElFulfilled.bind(null, outputs, i), replaceElRejected.bind(null, outputs, i)).then(function () {\n        if (--counter === 0) promise.resolve(outputs);\n      });\n    }\n  }\n  return promise;\n}\n\n/**\n * Create a new Promise which looks like a deferred\n *\n * @return {!Promise}\n */\nfunction defer() {\n  return new Promise();\n}\n\n/**\n * Return a promise which will wait a specified number of ms to resolve\n *\n * @param {*} delayMsOrVal A delay (in ms) if this takes one argument, or ther\n *     return value if it takes two.\n * @param {number=} opt_delayMs\n * @return {!Promise}\n */\nfunction delay(delayMsOrVal, opt_delayMs) {\n  var returnVal = undefined;\n  var delayMs = delayMsOrVal;\n  if (typeof opt_delayMs != 'undefined') {\n    delayMs = opt_delayMs;\n    returnVal = delayMsOrVal;\n  }\n  if (typeof delayMs != 'number') {\n    throw new Error('Bad delay value ' + delayMs);\n  }\n  var defer = new Promise();\n  setTimeout(function onDelay() {\n    defer.resolve(returnVal);\n  }, delayMs);\n  return defer;\n}\n\n/**\n * Returns a promise that has the same result as `this`, but fulfilled\n * after at least ms milliseconds\n * @param {number} ms\n */\nPromise.prototype.delay = function (ms) {\n  return this.then(function (val) {\n    return delay(val, ms);\n  });\n};\n\n/**\n * Return a promise which will evaluate the function fn in a future turn with\n * the provided args\n *\n * @param {function(...)} fn\n * @param {...*} var_args a variable number of arguments\n * @return {!Promise}\n */\nfunction fcall(fn, var_args) {\n  var rootArgs = Array.prototype.slice.call(arguments, 1);\n  var defer = new Promise();\n  process.nextTick(function onNextTick() {\n    try {\n      defer.resolve(fn.apply(undefined, rootArgs));\n    } catch (e) {\n      defer.reject(e);\n    }\n  });\n  return defer;\n}\n\n/**\n * Returns a promise that will be invoked with the result of a node style\n * callback. All args to fn should be given except for the final callback arg\n *\n * @param {function(...)} fn\n * @param {...*} var_args a variable number of arguments\n * @return {!Promise}\n */\nfunction nfcall(fn, var_args) {\n  // Insert an undefined argument for scope and let bindPromise() do the work.\n  var args = Array.prototype.slice.call(arguments, 0);\n  args.splice(1, 0, undefined);\n  return bindPromise.apply(undefined, args)();\n}\n\n/**\n * Binds a function to a scope with an optional number of curried arguments. Attaches\n * a node style callback as the last argument and returns a promise\n *\n * @param {function(...)} fn\n * @param {Object} scope\n * @param {...*} var_args a variable number of arguments\n * @return {function(...)}: !Promise}\n */\nfunction bindPromise(fn, scope, var_args) {\n  var rootArgs = Array.prototype.slice.call(arguments, 2);\n  return function onBoundPromise(var_args) {\n    var defer = new Promise();\n    try {\n      fn.apply(scope, rootArgs.concat(Array.prototype.slice.call(arguments, 0), defer.makeNodeResolver()));\n    } catch (e) {\n      defer.reject(e);\n    }\n    return defer;\n  };\n}\nmodule.exports = {\n  all: all,\n  bindPromise: bindPromise,\n  defer: defer,\n  delay: delay,\n  fcall: fcall,\n  isPromise: isPromise,\n  isPromiseLike: isPromiseLike,\n  nfcall: nfcall,\n  resolve: resolve,\n  reject: reject,\n  allSettled: allSettled,\n  Promise: Promise\n};","map":{"version":3,"names":["Promise","onSuccess","onFail","promise","_isPromise","_successFn","_failFn","_scope","_boundArgs","_hasContext","_nextContext","undefined","_currentContext","prototype","_useContext","context","clearContext","setContext","getContext","resolve","data","_error","_hasData","Error","i","isPromise","_child","_promises","length","_chainPromise","_onComplete","fin","isPromiseLike","then","bind","err","reject","_data","_withInput","e","_ended","process","nextTick","onPromiseThrow","_withError","thenBound","scope","var_args","arguments","Array","slice","call","fail","failBound","onComplete","push","end","_end","done","onFailure","self","timeout","timeoutMs","timeoutMsg","deferred","isTimeout","setTimeout","clearTimeout","_call","thrown","fn","args","concat","apply","resolver","makeNodeResolver","obj","replaceEl","arr","idx","val","replaceElFulfilled","value","state","replaceElRejected","reason","all","promises","isArray","outputs","finished","counter","decrementAllCounter","onAllError","allSettled","defer","delay","delayMsOrVal","opt_delayMs","returnVal","delayMs","onDelay","ms","fcall","rootArgs","onNextTick","nfcall","splice","bindPromise","onBoundPromise","module","exports"],"sources":["C:/game/mern/node_modules/kew/kew.js"],"sourcesContent":["\n/**\n * An object representing a \"promise\" for a future value\n *\n * @param {?function(T, ?)=} onSuccess a function to handle successful\n *     resolution of this promise\n * @param {?function(!Error, ?)=} onFail a function to handle failed\n *     resolution of this promise\n * @constructor\n * @template T\n */\nfunction Promise(onSuccess, onFail) {\n  this.promise = this\n  this._isPromise = true\n  this._successFn = onSuccess\n  this._failFn = onFail\n  this._scope = this\n  this._boundArgs = null\n  this._hasContext = false\n  this._nextContext = undefined\n  this._currentContext = undefined\n}\n\n/**\n * Specify that the current promise should have a specified context\n * @param  {*} context context\n * @private\n */\nPromise.prototype._useContext = function (context) {\n  this._nextContext = this._currentContext = context\n  this._hasContext = true\n  return this\n}\n\nPromise.prototype.clearContext = function () {\n  this._hasContext = false\n  this._nextContext = undefined\n  return this\n}\n\n/**\n * Set the context for all promise handlers to follow\n *\n * NOTE(dpup): This should be considered deprecated.  It does not do what most\n * people would expect.  The context will be passed as a second argument to all\n * subsequent callbacks.\n *\n * @param {*} context An arbitrary context\n */\nPromise.prototype.setContext = function (context) {\n  this._nextContext = context\n  this._hasContext = true\n  return this\n}\n\n/**\n * Get the context for a promise\n * @return {*} the context set by setContext\n */\nPromise.prototype.getContext = function () {\n  return this._nextContext\n}\n\n/**\n * Resolve this promise with a specified value\n *\n * @param {*=} data\n */\nPromise.prototype.resolve = function (data) {\n  if (this._error || this._hasData) throw new Error(\"Unable to resolve or reject the same promise twice\")\n\n  var i\n  if (data && isPromise(data)) {\n    this._child = data\n    if (this._promises) {\n      for (i = 0; i < this._promises.length; i += 1) {\n        data._chainPromise(this._promises[i])\n      }\n      delete this._promises\n    }\n\n    if (this._onComplete) {\n      for (i = 0; i < this._onComplete.length; i+= 1) {\n        data.fin(this._onComplete[i])\n      }\n      delete this._onComplete\n    }\n  } else if (data && isPromiseLike(data)) {\n    data.then(\n      function(data) { this.resolve(data) }.bind(this),\n      function(err) { this.reject(err) }.bind(this)\n    )\n  } else {\n    this._hasData = true\n    this._data = data\n\n    if (this._onComplete) {\n      for (i = 0; i < this._onComplete.length; i++) {\n        this._onComplete[i]()\n      }\n    }\n\n    if (this._promises) {\n      for (i = 0; i < this._promises.length; i += 1) {\n        this._promises[i]._withInput(data)\n      }\n      delete this._promises\n    }\n  }\n}\n\n/**\n * Reject this promise with an error\n *\n * @param {!Error} e\n */\nPromise.prototype.reject = function (e) {\n  if (this._error || this._hasData) throw new Error(\"Unable to resolve or reject the same promise twice\")\n\n  var i\n  this._error = e\n\n  if (this._ended) {\n    process.nextTick(function onPromiseThrow() {\n      throw e\n    })\n  }\n\n  if (this._onComplete) {\n    for (i = 0; i < this._onComplete.length; i++) {\n      this._onComplete[i]()\n    }\n  }\n\n  if (this._promises) {\n    for (i = 0; i < this._promises.length; i += 1) {\n      this._promises[i]._withError(e)\n    }\n    delete this._promises\n  }\n}\n\n/**\n * Provide a callback to be called whenever this promise successfully\n * resolves. Allows for an optional second callback to handle the failure\n * case.\n *\n * @param {?function(this:void, T, ?): RESULT|undefined} onSuccess\n * @param {?function(this:void, !Error, ?): RESULT=} onFail\n * @return {!Promise.<RESULT>} returns a new promise with the output of the onSuccess or\n *     onFail handler\n * @template RESULT\n */\nPromise.prototype.then = function (onSuccess, onFail) {\n  var promise = new Promise(onSuccess, onFail)\n  if (this._nextContext) promise._useContext(this._nextContext)\n\n  if (this._child) this._child._chainPromise(promise)\n  else this._chainPromise(promise)\n\n  return promise\n}\n\n/**\n * Provide a callback to be called whenever this promise successfully\n * resolves. The callback will be executed in the context of the provided scope.\n *\n * @param {function(this:SCOPE, T, ?): RESULT} onSuccess\n * @param {SCOPE} scope Object whose context callback will be executed in.\n * @param {...*} var_args Additional arguments to be passed to the promise callback.\n * @return {!Promise.<RESULT>} returns a new promise with the output of the onSuccess\n * @template SCOPE, RESULT\n */\nPromise.prototype.thenBound = function (onSuccess, scope, var_args) {\n  var promise = new Promise(onSuccess)\n  if (this._nextContext) promise._useContext(this._nextContext)\n\n  promise._scope = scope\n  if (arguments.length > 2) {\n    promise._boundArgs = Array.prototype.slice.call(arguments, 2)\n  }\n\n  // Chaining must happen after setting args and scope since it may fire callback.\n  if (this._child) this._child._chainPromise(promise)\n  else this._chainPromise(promise)\n\n  return promise\n}\n\n/**\n * Provide a callback to be called whenever this promise is rejected\n *\n * @param {function(this:void, !Error, ?)} onFail\n * @return {!Promise.<T>} returns a new promise with the output of the onFail handler\n */\nPromise.prototype.fail = function (onFail) {\n  return this.then(null, onFail)\n}\n\n/**\n * Provide a callback to be called whenever this promise is rejected.\n * The callback will be executed in the context of the provided scope.\n *\n * @param {function(this:SCOPE, Error, ?)} onFail\n * @param {SCOPE} scope Object whose context callback will be executed in.\n * @param {...?} var_args\n * @return {!Promise.<T>} returns a new promise with the output of the onSuccess\n * @template SCOPE\n */\nPromise.prototype.failBound = function (onFail, scope, var_args) {\n  var promise = new Promise(null, onFail)\n  if (this._nextContext) promise._useContext(this._nextContext)\n\n  promise._scope = scope\n  if (arguments.length > 2) {\n    promise._boundArgs = Array.prototype.slice.call(arguments, 2)\n  }\n\n  // Chaining must happen after setting args and scope since it may fire callback.\n  if (this._child) this._child._chainPromise(promise)\n  else this._chainPromise(promise)\n\n  return promise\n}\n\n/**\n * Provide a callback to be called whenever this promise is either resolved\n * or rejected.\n *\n * @param {function()} onComplete\n * @return {!Promise.<T>} returns the current promise\n */\nPromise.prototype.fin = function (onComplete) {\n  if (this._hasData || this._error) {\n    onComplete()\n    return this\n  }\n\n  if (this._child) {\n    this._child.fin(onComplete)\n  } else {\n    if (!this._onComplete) this._onComplete = [onComplete]\n    else this._onComplete.push(onComplete)\n  }\n\n  return this\n}\n\n/**\n * Mark this promise as \"ended\". If the promise is rejected, this will throw an\n * error in whatever scope it happens to be in\n *\n * @return {!Promise.<T>} returns the current promise\n * @deprecated Prefer done(), because it's consistent with Q.\n */\nPromise.prototype.end = function () {\n  this._end()\n  return this\n}\n\n\n/**\n * Mark this promise as \"ended\".\n * @private\n */\nPromise.prototype._end = function () {\n  if (this._error) {\n    throw this._error\n  }\n  this._ended = true\n  return this\n}\n\n/**\n * Close the promise. Any errors after this completes will be thrown to the global handler.\n *\n * @param {?function(this:void, T, ?)=} onSuccess a function to handle successful\n *     resolution of this promise\n * @param {?function(this:void, !Error, ?)=} onFailure a function to handle failed\n *     resolution of this promise\n * @return {void}\n */\nPromise.prototype.done = function (onSuccess, onFailure) {\n  var self = this\n  if (onSuccess || onFailure) {\n    self = self.then(onSuccess, onFailure)\n  }\n  self._end()\n}\n\n/**\n * Return a new promise that behaves the same as the current promise except\n * that it will be rejected if the current promise does not get fulfilled\n * after a certain amount of time.\n *\n * @param {number} timeoutMs The timeout threshold in msec\n * @param {string=} timeoutMsg error message\n * @return {!Promise.<T>} a new promise with timeout\n */\n Promise.prototype.timeout = function (timeoutMs, timeoutMsg) {\n  var deferred = new Promise()\n  var isTimeout = false\n\n  var timeout = setTimeout(function() {\n    deferred.reject(new Error(timeoutMsg || 'Promise timeout after ' + timeoutMs + ' ms.'))\n    isTimeout = true\n  }, timeoutMs)\n\n  this.then(function (data) {\n    if (!isTimeout) {\n      clearTimeout(timeout)\n      deferred.resolve(data)\n    }\n  },\n  function (err) {\n    if (!isTimeout) {\n      clearTimeout(timeout)\n      deferred.reject(err)\n    }\n  })\n\n  return deferred.promise\n}\n\n/**\n * Attempt to resolve this promise with the specified input\n *\n * @param {*} data the input\n */\nPromise.prototype._withInput = function (data) {\n  if (this._successFn) {\n    try {\n      this.resolve(this._call(this._successFn, [data, this._currentContext]))\n    } catch (e) {\n      this.reject(e)\n    }\n  } else this.resolve(data)\n\n  // context is no longer needed\n  delete this._currentContext\n}\n\n/**\n * Attempt to reject this promise with the specified error\n *\n * @param {!Error} e\n * @private\n */\nPromise.prototype._withError = function (e) {\n  if (this._failFn) {\n    try {\n      this.resolve(this._call(this._failFn, [e, this._currentContext]))\n    } catch (thrown) {\n      this.reject(thrown)\n    }\n  } else this.reject(e)\n\n  // context is no longer needed\n  delete this._currentContext\n}\n\n/**\n * Calls a function in the correct scope, and includes bound arguments.\n * @param {Function} fn\n * @param {Array} args\n * @return {*}\n * @private\n */\nPromise.prototype._call = function (fn, args) {\n  if (this._boundArgs) {\n    args = this._boundArgs.concat(args)\n  }\n  return fn.apply(this._scope, args)\n}\n\n/**\n * Chain a promise to the current promise\n *\n * @param {!Promise} promise the promise to chain\n * @private\n */\nPromise.prototype._chainPromise = function (promise) {\n  var i\n  if (this._hasContext) promise._useContext(this._nextContext)\n\n  if (this._child) {\n    this._child._chainPromise(promise)\n  } else if (this._hasData) {\n    promise._withInput(this._data)\n  } else if (this._error) {\n    promise._withError(this._error)\n  } else if (!this._promises) {\n    this._promises = [promise]\n  } else {\n    this._promises.push(promise)\n  }\n}\n\n/**\n * Utility function used for creating a node-style resolver\n * for deferreds\n *\n * @param {!Promise} deferred a promise that looks like a deferred\n * @param {Error=} err an optional error\n * @param {*=} data optional data\n */\nfunction resolver(deferred, err, data) {\n  if (err) deferred.reject(err)\n  else deferred.resolve(data)\n}\n\n/**\n * Creates a node-style resolver for a deferred by wrapping\n * resolver()\n *\n * @return {function(?Error, *)} node-style callback\n */\nPromise.prototype.makeNodeResolver = function () {\n  return resolver.bind(null, this)\n}\n\n/**\n * Return true iff the given object is a promise of this library.\n *\n * Because kew's API is slightly different than other promise libraries,\n * it's important that we have a test for its promise type. If you want\n * to test for a more general A+ promise, you should do a cap test for\n * the features you want.\n *\n * @param {*} obj The object to test\n * @return {boolean} Whether the object is a promise\n */\nfunction isPromise(obj) {\n  return !!obj._isPromise\n}\n\n/**\n * Return true iff the given object is a promise-like object, e.g. appears to\n * implement Promises/A+ specification\n *\n * @param {*} obj The object to test\n * @return {boolean} Whether the object is a promise-like object\n */\nfunction isPromiseLike(obj) {\n  return typeof obj === 'object' && typeof obj.then === 'function'\n}\n\n/**\n * Static function which creates and resolves a promise immediately\n *\n * @param {T} data data to resolve the promise with\n * @return {!Promise.<T>}\n * @template T\n */\nfunction resolve(data) {\n  var promise = new Promise()\n  promise.resolve(data)\n  return promise\n}\n\n/**\n * Static function which creates and rejects a promise immediately\n *\n * @param {!Error} e error to reject the promise with\n * @return {!Promise}\n */\nfunction reject(e) {\n  var promise = new Promise()\n  promise.reject(e)\n  return promise\n}\n\n/**\n * Replace an element in an array with a new value. Used by .all() to\n * call from .then()\n *\n * @param {!Array} arr\n * @param {number} idx\n * @param {*} val\n * @return {*} the val that's being injected into the array\n */\nfunction replaceEl(arr, idx, val) {\n  arr[idx] = val\n  return val\n}\n\n/**\n * Replace an element in an array as it is resolved with its value.\n * Used by .allSettled().\n *\n * @param {!Array} arr\n * @param {number} idx\n * @param {*} value The value from a resolved promise.\n * @return {*} the data that's being passed in\n */\nfunction replaceElFulfilled(arr, idx, value) {\n  arr[idx] = {\n    state: 'fulfilled',\n    value: value\n  }\n  return value\n}\n\n/**\n * Replace an element in an array as it is rejected with the reason.\n * Used by .allSettled().\n *\n * @param {!Array} arr\n * @param {number} idx\n * @param {*} reason The reason why the original promise is rejected\n * @return {*} the data that's being passed in\n */\nfunction replaceElRejected(arr, idx, reason) {\n  arr[idx] = {\n    state: 'rejected',\n    reason: reason\n  }\n  return reason\n}\n\n/**\n * Takes in an array of promises or literals and returns a promise which returns\n * an array of values when all have resolved. If any fail, the promise fails.\n *\n * @param {!Array.<!Promise>} promises\n * @return {!Promise.<!Array>}\n */\nfunction all(promises) {\n  if (arguments.length != 1 || !Array.isArray(promises)) {\n    promises = Array.prototype.slice.call(arguments, 0)\n  }\n  if (!promises.length) return resolve([])\n\n  var outputs = []\n  var finished = false\n  var promise = new Promise()\n  var counter = promises.length\n\n  for (var i = 0; i < promises.length; i += 1) {\n    if (!promises[i] || !isPromiseLike(promises[i])) {\n      outputs[i] = promises[i]\n      counter -= 1\n    } else {\n      promises[i].then(replaceEl.bind(null, outputs, i))\n      .then(function decrementAllCounter() {\n        counter--\n        if (!finished && counter === 0) {\n          finished = true\n          promise.resolve(outputs)\n        }\n      }, function onAllError(e) {\n        if (!finished) {\n          finished = true\n          promise.reject(e)\n        }\n      })\n    }\n  }\n\n  if (counter === 0 && !finished) {\n    finished = true\n    promise.resolve(outputs)\n  }\n\n  return promise\n}\n\n/**\n * Takes in an array of promises or values and returns a promise that is\n * fulfilled with an array of state objects when all have resolved or\n * rejected. If a promise is resolved, its corresponding state object is\n * {state: 'fulfilled', value: Object}; whereas if a promise is rejected, its\n * corresponding state object is {state: 'rejected', reason: Object}.\n *\n * @param {!Array} promises or values\n * @return {!Promise.<!Array>} Promise fulfilled with state objects for each input\n */\nfunction allSettled(promises) {\n  if (!Array.isArray(promises)) {\n    throw Error('The input to \"allSettled()\" should be an array of Promise or values')\n  }\n  if (!promises.length) return resolve([])\n\n  var outputs = []\n  var promise = new Promise()\n  var counter = promises.length\n\n  for (var i = 0; i < promises.length; i += 1) {\n    if (!promises[i] || !isPromiseLike(promises[i])) {\n      replaceElFulfilled(outputs, i, promises[i])\n      if ((--counter) === 0) promise.resolve(outputs)\n    } else {\n      promises[i]\n        .then(replaceElFulfilled.bind(null, outputs, i), replaceElRejected.bind(null, outputs, i))\n        .then(function () {\n          if ((--counter) === 0) promise.resolve(outputs)\n        })\n    }\n  }\n\n  return promise\n}\n\n/**\n * Create a new Promise which looks like a deferred\n *\n * @return {!Promise}\n */\nfunction defer() {\n  return new Promise()\n}\n\n/**\n * Return a promise which will wait a specified number of ms to resolve\n *\n * @param {*} delayMsOrVal A delay (in ms) if this takes one argument, or ther\n *     return value if it takes two.\n * @param {number=} opt_delayMs\n * @return {!Promise}\n */\nfunction delay(delayMsOrVal, opt_delayMs) {\n  var returnVal = undefined\n  var delayMs = delayMsOrVal\n  if (typeof opt_delayMs != 'undefined') {\n    delayMs = opt_delayMs\n    returnVal = delayMsOrVal\n  }\n\n  if (typeof delayMs != 'number') {\n    throw new Error('Bad delay value ' + delayMs)\n  }\n\n  var defer = new Promise()\n  setTimeout(function onDelay() {\n    defer.resolve(returnVal)\n  }, delayMs)\n  return defer\n}\n\n/**\n * Returns a promise that has the same result as `this`, but fulfilled\n * after at least ms milliseconds\n * @param {number} ms\n */\nPromise.prototype.delay = function (ms) {\n  return this.then(function (val) {\n    return delay(val, ms)\n  })\n}\n\n/**\n * Return a promise which will evaluate the function fn in a future turn with\n * the provided args\n *\n * @param {function(...)} fn\n * @param {...*} var_args a variable number of arguments\n * @return {!Promise}\n */\nfunction fcall(fn, var_args) {\n  var rootArgs = Array.prototype.slice.call(arguments, 1)\n  var defer = new Promise()\n  process.nextTick(function onNextTick() {\n    try {\n      defer.resolve(fn.apply(undefined, rootArgs))\n    } catch (e) {\n      defer.reject(e)\n    }\n  })\n  return defer\n}\n\n\n/**\n * Returns a promise that will be invoked with the result of a node style\n * callback. All args to fn should be given except for the final callback arg\n *\n * @param {function(...)} fn\n * @param {...*} var_args a variable number of arguments\n * @return {!Promise}\n */\nfunction nfcall(fn, var_args) {\n  // Insert an undefined argument for scope and let bindPromise() do the work.\n  var args = Array.prototype.slice.call(arguments, 0)\n  args.splice(1, 0, undefined)\n  return bindPromise.apply(undefined, args)()\n}\n\n\n/**\n * Binds a function to a scope with an optional number of curried arguments. Attaches\n * a node style callback as the last argument and returns a promise\n *\n * @param {function(...)} fn\n * @param {Object} scope\n * @param {...*} var_args a variable number of arguments\n * @return {function(...)}: !Promise}\n */\nfunction bindPromise(fn, scope, var_args) {\n  var rootArgs = Array.prototype.slice.call(arguments, 2)\n  return function onBoundPromise(var_args) {\n    var defer = new Promise()\n    try {\n      fn.apply(scope, rootArgs.concat(Array.prototype.slice.call(arguments, 0), defer.makeNodeResolver()))\n    } catch (e) {\n      defer.reject(e)\n    }\n    return defer\n  }\n}\n\nmodule.exports = {\n    all: all\n  , bindPromise: bindPromise\n  , defer: defer\n  , delay: delay\n  , fcall: fcall\n  , isPromise: isPromise\n  , isPromiseLike: isPromiseLike\n  , nfcall: nfcall\n  , resolve: resolve\n  , reject: reject\n  , allSettled: allSettled\n  , Promise: Promise\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}